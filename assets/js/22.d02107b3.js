(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{343:function(t,s,e){"use strict";e.r(s);var a=e(7),v=Object(a.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"数据结构和内部编码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据结构和内部编码"}},[t._v("#")]),t._v(" 数据结构和内部编码")]),t._v(" "),s("p",[t._v("type 命令实际返回的就是当前键对应的 value（值对象）的数据结构类型，它们分别是：string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合），但这些只是 Redis 对外的数据结构。")]),t._v(" "),s("blockquote",[s("p",[s("strong",[t._v("在 Redis 中，键和值都是一个对象，键总是一个字符串对象，而值可以是字符串、列表、集合等对象，所以我们通常说键为字符串键，表示这个键对应的值为字符串对象，我们说一个键为集合键时，表示这个键对应的值为集合对象")])])]),t._v(" "),s("p",[t._v("实际上每种数据结构都有自己底层的内部编码实现，而且是多种实现，这样 Redis 会在合适的场景选择合适的内部编码。")]),t._v(" "),s("p",[t._v("每种数据结构都有两种以上的内部编码实现，例如 list 数据结构包含了 linkedlist 和 ziplist 两种内部编码。同时有些内部编码，例如 ziplist，可以作为多种外部数据结构的内部实现，可以通过"),s("code",[t._v("object encoding")]),t._v("命令查询内部编码：")]),t._v(" "),s("div",{staticClass:"language-sh extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sh"}},[s("code",[s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("set")]),t._v(" hello "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"nihao"')]),t._v("\nobject encoding hello\n"),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"embstr"')]),t._v("\nlpush mylist a\nobject encoding mylist\n"),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"ziplist"')]),t._v("\n")])])]),s("p",[t._v("可以看到键 hello 对应值对象的内部编码是 embstr，键 mylist 对应值对象的内部编码是 ziplist。")]),t._v(" "),s("p",[t._v("Redis这样设计有两个好处：")]),t._v(" "),s("ol",[s("li",[t._v("可以改进内部编码，而对外的数据结构和命令没有影响，这样一旦开发出更优秀的内部编码，无需改动外部数据结构和命令，例如 Redis3.2 提供了quicklist，结合了 ziplist 和 linkedlist 两者的优势，为列表类型提供了一种更为优秀的内部编码实现，而对外部用户来说基本感知不到。")]),t._v(" "),s("li",[t._v("多种内部编码实现可以在不同场景下发挥各自的优势，例如 ziplist 比较节省内存，但是在列表元素比较多的情况下，性能会有所下降，这时候 Redis 会根据配置选项将列表类型的内部实现转换为 linkedlist。")])]),t._v(" "),s("blockquote",[s("p",[t._v("Redis 的 embstr 编码方式和 raw 编码方式在 3.2 版本之前是以 39 字节为分界的，后续版本以 44 为分界。\n也就是说，在 redis5.0.4 版本中，如果一个字符串值的长度小于等于 44 字节，则按照 embst 进行编码，否则按照 raw 进行编码。")])]),t._v(" "),s("h2",{attrs:{id:"redis构建的类型系统"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis构建的类型系统"}},[t._v("#")]),t._v(" Redis构建的类型系统")]),t._v(" "),s("h3",{attrs:{id:"redisobject对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redisobject对象"}},[t._v("#")]),t._v(" redisObject对象")]),t._v(" "),s("p",[t._v("Redis 内部使用一个 redisObject 对象来表示所有的 key 和 value，每次在 Redis 数据块中创建一个键值对时，"),s("strong",[t._v("一个是键对象，一个是值对象，而 Redis 中的每个对象都是由 redisObject 结构来表示")]),t._v("。")]),t._v(" "),s("p",[s("strong",[t._v("在 Redis 中，键总是一个字符串对象，而值可以是字符串、列表、集合等对象，所以我们通常说键为字符串键，表示这个键对应的值为字符串对象，我们说一个键为集合键时，表示这个键对应的值为集合对象。")])]),t._v(" "),s("p",[t._v("redisobject 最主要的信息：")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// redisobject源码")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("redisObject")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n     "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//类型")]),t._v("\n     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("unsigned")]),t._v(" type"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n     "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//编码")]),t._v("\n     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("unsigned")]),t._v(" encoding"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n     "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//指向底层数据结构的指针")]),t._v("\n     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("ptr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n     "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//引用计数")]),t._v("\n     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" refcount"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n     "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//记录最后一次被程序访问的时间")]),t._v("\n     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("unsigned")]),t._v(" lru"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("22")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" robj\n")])])]),s("ol",[s("li",[s("code",[t._v("type")]),t._v("字段：表示当前对象使用的数据类型，Redis 主要支持5种数据类型：string、hash、list、set、zset。可以使用 type {key} 命令查看对象所属类型，type 命令返回的是"),s("strong",[t._v("值对象")]),t._v("类型，键都是 string 类型。")]),t._v(" "),s("li",[s("code",[t._v("encoding")]),t._v("字段：表示 Redis 内部编码类型，encoding 在 Redis 内部使用，代表当前对象内部采用哪种数据结构实现。可以使用"),s("code",[t._v("object encoding {key}")]),t._v("命令查看对象所属的类型对应的内部数据结构。")]),t._v(" "),s("li",[s("code",[t._v("lur")]),t._v("字段：记录对象最后一次被访问的时间，当配置了"),s("code",[t._v("maxmemory")]),t._v("和"),s("code",[t._v("maxmemory-policy=volatile-lru")]),t._v("或者"),s("code",[t._v("allkeys-lru")]),t._v("时，用于辅助 LRU 算法删除键数据。可以使用"),s("code",[t._v("object idletime {key}")]),t._v("命令在不更新 lru 字段情况下查看当前键的"),s("strong",[t._v("空闲时间")]),t._v("。")]),t._v(" "),s("li",[s("code",[t._v("refcount")]),t._v("字段：记录当前对象被引用的次数，用于通过引用次数回收内存，当 refcount=0 时，可以安全回收当前对象空间。使用"),s("code",[t._v("object refcount {key}")]),t._v("获取当前对象引用。")]),t._v(" "),s("li",[s("code",[t._v("ptr")]),t._v("字段：与对象的数据内容相关，如果是整数，直接存储数据；否则表示指向数据的指针。Redis 在 3.0 之后对值对象是字符串且长度 <=39 字节的数据，内部编码为 embstr 类型，字符串 sds 和 redisObject 一起分配，从而只要一次内存操作即可。")])]),t._v(" "),s("h3",{attrs:{id:"命令的类型检查和多态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#命令的类型检查和多态"}},[t._v("#")]),t._v(" 命令的类型检查和多态")]),t._v(" "),s("h4",{attrs:{id:"redis命令分类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis命令分类"}},[t._v("#")]),t._v(" Redis命令分类")]),t._v(" "),s("ul",[s("li",[t._v("一种是只能用于对应数据类型的命令，例如"),s("code",[t._v("LPUSH")]),t._v("和"),s("code",[t._v("LLEN")]),t._v("只能用于列表键， "),s("code",[t._v("SADD")]),t._v(" 和 "),s("code",[t._v("SRANDMEMBER")]),t._v("只能用于集合键。")]),t._v(" "),s("li",[t._v("另一种是可以用于任何类型键的命令。比如"),s("code",[t._v("TTL")]),t._v("。")])]),t._v(" "),s("p",[t._v("当执行一个处理数据类型的命令时，Redis执行以下步骤：")]),t._v(" "),s("ul",[s("li",[t._v("根据给定 "),s("code",[t._v("key")]),t._v(" ，在数据库字典中查找和它相对应的 "),s("code",[t._v("redisObject")]),t._v(" ，如果没找到，就返回 "),s("code",[t._v("NULL")]),t._v(" 。")]),t._v(" "),s("li",[t._v("检查 "),s("code",[t._v("redisObject")]),t._v(" 的 "),s("code",[t._v("type")]),t._v(" 属性和执行命令所需的类型是否相符，如果不相符，返回类型错误。")]),t._v(" "),s("li",[t._v("根据 "),s("code",[t._v("redisObject")]),t._v(" 的 "),s("code",[t._v("encoding")]),t._v(" 属性所指定的编码，选择合适的操作函数来处理底层的数据结构。")]),t._v(" "),s("li",[t._v("返回数据结构的操作结果作为命令的返回值。")])]),t._v(" "),s("h2",{attrs:{id:"_5种数据类型对应的编码和数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5种数据类型对应的编码和数据结构"}},[t._v("#")]),t._v(" 5种数据类型对应的编码和数据结构")]),t._v(" "),s("h3",{attrs:{id:"string"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#string"}},[t._v("#")]),t._v(" string")]),t._v(" "),s("p",[s("strong",[t._v("string 是最常用的一种数据类型，普通的 key/value 存储都可以归结为 string 类型，value 不仅是 string，也可以是数字。其他几种数据类型的构成元素也都是字符串，注意 Redis 规定字符串的长度不能超过"),s("span",{staticStyle:{color:"red"}},[t._v(" 512M")])])]),t._v(" "),s("h4",{attrs:{id:"编码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编码"}},[t._v("#")]),t._v(" 编码")]),t._v(" "),s("p",[s("strong",[t._v("编码字符串对象的编码可以是int、raw、embstr")])]),t._v(" "),s("ul",[s("li",[t._v("int 编码：保存的是可以用 long 类型表示的整数值")]),t._v(" "),s("li",[t._v("raw 编码：保存长度大于 44 字节的字符串")]),t._v(" "),s("li",[t._v("embstr 编码：保存长度小于 44 字节的字符串")])]),t._v(" "),s("blockquote",[s("p",[t._v("int 用来保存整数值，raw 用来保存长字符串，embstr 用来保存短字符串。embstr 编码是用来专门保存短字符串的一种优化编码。"),s("strong",[t._v("Redis 中对于浮点型也是作为字符串保存的，在需要时再将其转换成浮点数类型。")])])]),t._v(" "),s("h4",{attrs:{id:"编码的转换"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编码的转换"}},[t._v("#")]),t._v(" 编码的转换")]),t._v(" "),s("ul",[s("li",[t._v("当 int 编码保存的值不再是整数，或大小超过了 long 的范围时，自动转化为 raw")]),t._v(" "),s("li",[t._v("对于 embstr 编码，由于 Redis 没有对其编写任何的修改程序（embstr 是只读的），在对 embstr 对象进行修改时，都会先转化为 raw 再进行修改，因此，只要是修改 embstr 对象，修改后的对象一定是 raw 的，无论是否达到了 44 个字节。")])]),t._v(" "),s("h4",{attrs:{id:"常用命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常用命令"}},[t._v("#")]),t._v(" 常用命令")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("操作")]),t._v(" "),s("th",[t._v("解释")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("set")]),t._v(" "),s("td",[t._v("设置 key 对应的值为 string 类型的 value （多次 set name 会覆盖）")])]),t._v(" "),s("tr",[s("td",[t._v("get")]),t._v(" "),s("td",[t._v("获取 key 对应的值")])]),t._v(" "),s("tr",[s("td",[t._v("mset")]),t._v(" "),s("td",[t._v("批量设置多个 key 的值，如果成功表示所有值都被设置，否则返回 0 表示没有任何值被设置")])]),t._v(" "),s("tr",[s("td",[t._v("mget")]),t._v(" "),s("td",[t._v("批量获取多个 key 的值，如果不存在则返回 null")])])])]),t._v(" "),s("div",{staticClass:"language-sh extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sh"}},[s("code",[t._v("mset user1:name redis user1:age "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("22")]),t._v("\nOK\nmget user1:name user1:age\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"redis"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"22"')]),t._v("\n")])])]),s("h4",{attrs:{id:"应用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[t._v("#")]),t._v(" 应用场景")]),t._v(" "),s("ul",[s("li",[t._v("因为 string 类型是二进制安全的，可以用来存放图片，视频等内容。")]),t._v(" "),s("li",[t._v("由于 redis 的高性能的读写功能，而 string 类型的 value 也可以是数字，可以用做计数器（使用 INCR，DECR 指令）。比如分布式环境中统计系统的在线人数，秒杀等。")]),t._v(" "),s("li",[t._v("除了上面提到的，还有用于 SpringSession 实现分布式 session")]),t._v(" "),s("li",[t._v("分布式系统全局序列号")])]),t._v(" "),s("h3",{attrs:{id:"list"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#list"}},[t._v("#")]),t._v(" list")]),t._v(" "),s("p",[s("strong",[t._v("list 列表,它是简单的字符串列表，你可以添加一个元素到列表的头部，或者尾部")]),t._v("。")]),t._v(" "),s("h4",{attrs:{id:"编码-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编码-2"}},[t._v("#")]),t._v(" 编码")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("列表对象的编码可以是 ziplist（压缩列表）和 linkedlist（双端链表）")])]),t._v(" "),s("li",[s("p",[t._v("编码转换")]),t._v(" "),s("ul",[s("li",[t._v("同时满足下面两个条件时使用压缩列表："),s("strong",[t._v("列表保存元素个数小于 512 个、每个元素长度小于 64 字节")])]),t._v(" "),s("li",[t._v("不能满足上面两个条件使用 linkedlist（双端列表）编码")])])])]),t._v(" "),s("h4",{attrs:{id:"实现数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实现数据结构"}},[t._v("#")]),t._v(" 实现数据结构")]),t._v(" "),s("ul",[s("li",[t._v("Stack（栈）：LPUSH+LPOP")]),t._v(" "),s("li",[t._v("Queue（队列）：LPUSH + RPOP")]),t._v(" "),s("li",[t._v("Blocking MQ（阻塞队列）：LPUSH+BRPOP")])]),t._v(" "),s("h4",{attrs:{id:"应用场景-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用场景-2"}},[t._v("#")]),t._v(" 应用场景")]),t._v(" "),s("ul",[s("li",[t._v("实现简单的消息队列")]),t._v(" "),s("li",[t._v("利用 LRANGE 命令，实现基于 Redis 的分页功能")])]),t._v(" "),s("h3",{attrs:{id:"set"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[t._v("#")]),t._v(" set")]),t._v(" "),s("p",[s("strong",[t._v("集合对象 set 是 string 类型（整数也会转成 string 类型进行存储）的无序集合。注意集合和列表的区别：集合中的元素是无序的，因此不能通过索引来操作元素；集合中的元素不能有重复。")])]),t._v(" "),s("h4",{attrs:{id:"编码-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编码-3"}},[t._v("#")]),t._v(" 编码")]),t._v(" "),s("p",[t._v("集合对象的编码可以是"),s("code",[t._v("intset")]),t._v("或者"),s("code",[t._v("hashtable")])]),t._v(" "),s("ul",[s("li",[s("code",[t._v("intset")]),t._v("（整数集合）：当集合中的元素都是整数且元素个数小于"),s("code",[t._v("set-max-intset-entries")]),t._v("配置（默认512个）时，Redis会选用"),s("code",[t._v("intset")]),t._v("来作为集合的内部实现，从而减少内存的使用。")]),t._v(" "),s("li",[s("code",[t._v("hashtable")]),t._v("编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，这里的每个字符串对象就是一个集合中的元素，而字典的值全部设置为 null。"),s("strong",[t._v("当使用 HT 编码时，Redis 中的集合 SET 相当于 Java 中的 HashSet，内部的键值对是无序的，唯一的。内部实现相当于一个特殊的字典，字典中所有 value 都是 NULL。")])])]),t._v(" "),s("p",[t._v("编码转换")]),t._v(" "),s("ul",[s("li",[t._v("当集合满足下列两个条件时，使用intset编码：\n"),s("ul",[s("li",[t._v("集合对象中的所有元素都是整数")]),t._v(" "),s("li",[t._v("集合对象所有元素数量不超过512")])])])]),t._v(" "),s("h4",{attrs:{id:"应用场景-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用场景-3"}},[t._v("#")]),t._v(" 应用场景")]),t._v(" "),s("ul",[s("li",[t._v("对于 set 数据类型，由于底层是字典实现的，查找元素特别快，另外 set 数据类型不允许重复，利用这两个特性我们可以进行全局去重，比如在用户注册模块，判断用户名是否注册；微信点赞，微信抽奖小程序")]),t._v(" "),s("li",[t._v("另外就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好，可能认识的人等功能。")])]),t._v(" "),s("h3",{attrs:{id:"zset"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#zset"}},[t._v("#")]),t._v(" zset")]),t._v(" "),s("p",[s("strong",[t._v("和集合对象相比，有序集合对象是有序的。与列表使用索引下表作为排序依据不同，有序集合为每一个元素设置一个分数（score）作为排序依据。")])]),t._v(" "),s("h4",{attrs:{id:"编码-4"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编码-4"}},[t._v("#")]),t._v(" 编码")]),t._v(" "),s("p",[t._v("有序集合的编码可以使ziplist或者skiplist")]),t._v(" "),s("ul",[s("li",[t._v("ziplist 编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个节点保存元素的分值。并且压缩列表内的集合元素按分值从小到大的顺序进行排列，小的放置在靠近表头的位置，大的放置在靠近表尾的位置。")]),t._v(" "),s("li",[t._v("skiplist 编码的有序集合对象使用 zset 结构作为底层实现，一个 zset 结构同时包含一个字典和一个跳跃表。")]),t._v(" "),s("li",[t._v("skiplist 和 ziplist 实现的具体不同可以参考"),s("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fblog.csdn.net%2Fmytt_10566%2Farticle%2Fdetails%2F94664942",target:"_blank",rel:"noopener noreferrer"}},[t._v("这里"),s("OutboundLink")],1),t._v("。")])]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("zset")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//跳跃表")]),t._v("\nzskiplist "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("zsl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//字典")]),t._v("\ndict "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("dice"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("zset\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//字典的键保存元素的成员，字典的值保存元素的分值，跳跃表节点的object属性保存元素的成员，跳跃表节点的score属性保存元素的分值。这两种数据结构会通过指针来共享相同元素的成员和分值，所以不会产生重复成员和分值，造成内存的浪费。")]),t._v("\n")])])]),s("h4",{attrs:{id:"编码转换"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编码转换"}},[t._v("#")]),t._v(" 编码转换")]),t._v(" "),s("p",[t._v("当有序结合对象同时满足以下两个条件时，对象使用 ziplist 编码，否则使用 skiplist 编码：")]),t._v(" "),s("ul",[s("li",[t._v("保存的元素数量小于128")]),t._v(" "),s("li",[t._v("保存的所有元素长度都小于64字节")])])])}),[],!1,null,null,null);s.default=v.exports}}]);