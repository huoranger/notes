(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{344:function(a,r,v){"use strict";v.r(r);var t=v(7),_=Object(t.a)({},(function(){var a=this,r=a._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h2",{attrs:{id:"kafka-基础架构理论"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#kafka-基础架构理论"}},[a._v("#")]),a._v(" Kafka 基础架构理论")]),a._v(" "),r("h3",{attrs:{id:"什么是-kafka"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是-kafka"}},[a._v("#")]),a._v(" 什么是 Kafka")]),a._v(" "),r("p",[a._v("Kafka 是一个使用 Scala 语言编写的基于 ZooKeeper 的高吞吐量低延迟的分布式发布与订阅消息系统，它可以实时处理大量消息数据以满足各种需求，比如基于 Hadoop 的批处理系统，低延迟的实时系统等。即便使用非常普通的硬件，Kafka 每秒也可以处理数百万条消息、其延迟最低只有几毫秒。\n在实际开发中，Kafka 常常作为 Spark Streaming 的实时数据源，Spark Streaming 从 Kafka 中读取实时消息进行处理，保证了数据的可靠性与实时性。二者是实时消息处理系统的重要组成部分。\n")]),a._v(" "),r("h3",{attrs:{id:"基本概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[a._v("#")]),a._v(" 基本概念")]),a._v(" "),r("ul",[r("li",[r("strong",[a._v("消息（Message）")]),a._v("：Kafka 的数据单元被称为消息。可以把消息看成是数据库里的一行数据或一条记录。为了提高效率，消息可以分组传输，每一组消息就是一个批次，分成批次传输可以减少网络开销。但是批次越大，单位时间内处理的消息就越大，因此要在吞吐量和时间延迟之间做出权衡。")]),a._v(" "),r("li",[r("strong",[a._v("服务器节点（Broker）")]),a._v("：Kafka 集群包含一个或多个服务器节点，一个独立的服务器节点被称为 Broker。")]),a._v(" "),r("li",[r("strong",[a._v("主题 （Topic）")]),a._v("：每条发布到 Kafka 集群的消息都有一个类别，这个类别被称为主题。在物理上，不同主题的消息分开存储；在逻辑上，一个主题的消息虽然保存于一个或多个 Broker 上，但用户只需指定消息的主题即可生产或消费消息，而不必关心消息存于何处。主题在逻辑上可以被认为是一个队列。每条消息都必须指定它的主题，可以简单理解为必须指明把这条消息放进哪个队列里。")]),a._v(" "),r("li",[r("strong",[a._v("分区 （Partition）")]),a._v("：为了使 Kafka 的吞吐率可以水平扩展，物理上把主题分成一个或多个分区。创建主题时可指定分区数量。每个分区对应于一个文件夹，该文件夹下存储该分区的数据和索引文件。")]),a._v(" "),r("li",[r("strong",[a._v("生产者（Producer）")]),a._v("：负责发布消息到 Kafka 的 Broker，实际上属于 Broker 的一种客户端。生产者负责选择哪些消息应该分配到哪个主题内的哪个分区。默认生产者会把消息均匀地分布到特定主题的所有分区上，但在某些情况下，生产者会将消息直接写到指定的分区。")]),a._v(" "),r("li",[r("strong",[a._v("消费者（Consumer")]),a._v("）：从 Kafka 的 Broker 上读取消息的客户端。读取消息时需要指定读取的主题，通常消费者会订阅一个或多个主题，并按照消息生成的顺序读取它们。")])]),a._v(" "),r("h3",{attrs:{id:"kafka架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#kafka架构"}},[a._v("#")]),a._v(" Kafka架构")]),a._v(" "),r("p",[a._v("在 Kafka 中，客户端和服务器之间的通信是通过一个简单的、高性能的、与语言无关的 TCP 协议完成的。该协议进行了版本控制，并与旧版本保持向后兼容。Kafka不仅提供 Java 客户端，也提供其他多种语言的客户端。")]),a._v(" "),r("p",[a._v("一个典型的 Kafka 集群中包含若干生产者（数据可以是 Web 前端产生的页面内容或者服务器日志等）、若干 Broker、若干消费者（可以是 Hadoop 集群、实时监控程序、数据仓库或其他服务）以及一个ZooKeeper集群。ZooKeeper用于管理和协调Broker。当Kafka系统中新增了Broker或者某个Broker故障失效时，ZooKeeper将通知生产者和消费者。生产者和消费者据此开始与其他Broker协调工作。")]),a._v(" "),r("p",[a._v("Kafka的集群架构如下图所示。生产者使用Push模式将消息发送到Broker，而消费者使用Pull模式从Broker订阅并消费消息。")]),a._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/10385897/1661481212923-44c8d229-898f-40d5-979b-caf513c4c098.png",alt:"图片.png"}})]),a._v(" "),r("h3",{attrs:{id:"主题与分区"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#主题与分区"}},[a._v("#")]),a._v(" 主题与分区")]),a._v(" "),r("p",[a._v("Kafka通过主题对消息进行分类，一个主题可以分为多个分区，且每个分区可以存储于不同的Broker上，也就是说，一个主题可以横跨多个服务器。")]),a._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/10385897/1661481245445-aaf15aaf-2cd8-4c38-8113-34f137832ac0.png",alt:"图片.png"}})]),a._v(" "),r("p",[a._v("**对主题进行分区的好处是：**允许主题消息规模超出一台服务器的文件大小上限。因为一个主题可以有多个分区，且可以存储在不同的服务器上，当一个分区的文件大小超出了所在服务器的文件大小上限时，可以动态添加其他分区，因此可以处理无限量的数据。")]),a._v(" "),r("p",[a._v("Kafka会为每个主题维护一个"),r("strong",[a._v("分区日志")]),a._v("，"),r("strong",[a._v("记录各个分区的消息存放情况")]),a._v("。消息以追加的方式写入每个分区的尾部，然后以先入先出的顺序进行读取。由于一个主题包含多个分区，"),r("font",{staticStyle:{color:"green"}},[a._v("因此无法在整个主题范围内保证消息的顺序，但可以保证单个分区内消息的顺序。")])],1),a._v(" "),r("p",[a._v("分区中的每个记录都被分配了一个"),r("strong",[a._v("偏移量（Offset）")]),a._v("，偏移量是"),r("strong",[a._v("一个连续递增的整数值")]),a._v("，它"),r("strong",[a._v("唯一标识分区中的某个记录")]),a._v("。而消费者只需保存该偏移量即可，当消费者客户端向Broker发起消息请求时需要携带偏移量。")]),a._v(" "),r("p",[a._v("例如，消费者向Broker请求主题test的分区0中的偏移量从20开始的所有消息以及主题test的分区1中的偏移量从35开始的所有消息。当消费者读取消息后，偏移量会线性递增。当然，消费者也可以按照任意顺序消费消息，比如读取已经消费过的"),r("strong",[a._v("历史消息")]),a._v("（将偏移量重置到之前版本）。")]),a._v(" "),r("p",[a._v("此外，"),r("strong",[a._v("消费者还可以指定从某个分区中一次最多返回多少条数据，防止一次返回数据太多而耗尽客户端的内存")]),a._v("。")]),a._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/10385897/1661481502309-daf44994-9810-4029-a615-ce4fd2855cff.png",alt:"图片.png"}})]),a._v(" "),r("p",[a._v("对于已经发布的消息，无论这些消息是否被消费，Kafka都将会保留一段时间，具体的"),r("strong",[a._v("保留策略")]),a._v("有两种：根据"),r("strong",[a._v("时间")]),a._v("保留（例如7天）和根据"),r("strong",[a._v("消息大小")]),a._v("保留（例如1GB），可以进行相关参数配置，选择具体策略。")]),a._v(" "),r("p",[a._v("当消息数量达到配置的策略上限时，Kafka就会为节省磁盘空间而将旧消息删除。例如，设置消息保留两天，则两天内该消息可以随时被消费，但两天后该消息将被删除。Kafka的性能对数据大小不敏感，因此保留大量数据毫无压力。")]),a._v(" "),r("p",[a._v("每个主题也可以配置自己的保留策略，可以根据具体的业务进行设置。例如，用于跟踪用户活动的数据可能需要保留几天，而应用程序的度量指标可能只需要保留几个小时。")]),a._v(" "),r("h3",{attrs:{id:"分区副本"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分区副本"}},[a._v("#")]),a._v(" 分区副本")]),a._v(" "),r("p",[a._v("在Kafka集群中，为了提高数据的可靠性，同一个分区可以复制多个副本分配到不同的Broker，这种方式类似于HDFS中的副本机制。如果其中一个Broker宕机，其他Broker可以接替宕机的Broker，不过生产者和消费者需要重新连接到新的Broker。Kafka分区的复制如图:")]),a._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/10385897/1661481609713-a323a2d5-49de-4f54-a05c-de0d5f8fa1ab.png",alt:"图片.png"}})]),a._v(" "),r("p",[r("strong",[a._v("Kafka每个分区的副本都被分为两种类型：领导者副本和跟随者副本。领导者副本只有一个，其余的都是跟随者副本。所有生产者和消费者都向领导者副本发起请求，进行消息的写入与读取，而跟随者副本并不处理客户端的请求，它唯一的任务是从领导者副本复制消息，以保持与领导者副本数据及状态的一致。")])]),a._v(" "),r("p",[a._v("如果领导者副本发生崩溃，就会从其余的跟随者副本中选出一个作为新的领导者副本。领导者与跟随者在Kafka集群中的分布如图:")]),a._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/10385897/1661481658440-4f9e2db9-ca0b-4c4d-9747-0e02afeab456.png",alt:"图片.png"}})]),a._v(" "),r("p",[a._v("跟随者为了与领导者保持同步，会周期性地向领导者发起获取数据的请求（Pull），这种请求与消费者读取消息发送的请求是一样的。请求消息里包含跟随者想要获取消息的偏移量，偏移量的值随着每次请求进行递增。领导者从跟随者请求的偏移量可以知道消息复制的进度。")]),a._v(" "),r("p",[a._v("Kafka的消息复制是以分区为单位的，既不是完全的同步复制，又不是完全的异步复制，而是基于"),r("strong",[a._v("ISR")]),a._v("（In-Sync Replica）的动态复制方案。")]),a._v(" "),r("p",[r("strong",[a._v("领导者会维护一个需要与其保持同步的副本列表（包括领导者自己），该列表称为ISR")]),a._v("，**且每个分区都会有一个ISR。**如果在一定时间内（可以通过参数replica.lag.time.max.ms进行配置），跟随者没有向领导者请求新的消息（可能由于网络问题），该跟随者将被认为是不同步的，领导者会从ISR中将其移除，从而避免因跟随者的请求速度过慢而拖慢整体速度。而当跟随者重新与领导者保持同步，领导者会将其再次加入ISR中。当领导者失效时，也不会选择ISR中不存在的跟随者作为新的领导者。")]),a._v(" "),r("p",[a._v("ISR的列表数据保存在ZooKeeper中，每次ISR改变后，领导者都会将最新的ISR同步到ZooKeeper中。")]),a._v(" "),r("h3",{attrs:{id:"消费者组"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#消费者组"}},[a._v("#")]),a._v(" 消费者组")]),a._v(" "),r("p",[a._v("消费者组（Consumer Group）实际上就是一组消费者的集合。每个消费者属于一个特定的消费者组（可为每个消费者指定组名称，消费者通过组名称对自己进行标识，若不指定组名称，则属于默认的组）。")]),a._v(" "),r("p",[a._v("传统消息处理有两种模式："),r("strong",[a._v("队列模式和发布订阅模式")])]),a._v(" "),r("ul",[r("li",[r("ul",[r("li",[r("strong",[a._v("队列模式")]),a._v("是指消费者可以从一台服务器读取消息，并且每个消息只被其中一个消费者消费；")]),a._v(" "),r("li",[r("strong",[a._v("发布订阅模式")]),a._v("是指消息通过广播方式发送给所有消费者。")])])])]),a._v(" "),r("p",[a._v("Kafka提供了消费者组模式，同时具备这两种（队列和发布订阅）模式的特点。")])])}),[],!1,null,null,null);r.default=_.exports}}]);